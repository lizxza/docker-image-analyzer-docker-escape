using System.Text.RegularExpressions;
using DockerAnalyze.Models;

namespace DockerAnalyze.Analyzers;

/// <summary>
/// Анализатор уязвимостей и потенциальных проблем безопасности
/// </summary>
public class VulnerabilityAnalyzer
{
    private readonly string _extractedPath;
    private readonly List<VulnerabilityFinding> _findings = new();

    public VulnerabilityAnalyzer(string extractedPath)
    {
        _extractedPath = extractedPath;
    }

    /// <summary>
    /// Выполняет поиск уязвимостей
    /// </summary>
    public async Task<List<VulnerabilityFinding>> AnalyzeAsync(FileSystemAnalysis? fileSystemAnalysis)
    {
        await Task.Run(() =>
        {
            SearchForSecrets();
            AnalyzeConfigurationFiles();
            SearchSensitiveFiles();
            AnalyzeNetworkConfigurations();
            AnalyzeOldLibraries();
            SearchDebugTools();
        });

        return _findings;
    }

    /// <summary>
    /// Поиск секретов и токенов в файлах
    /// </summary>
    private void SearchForSecrets()
    {
        var secretPatterns = new Dictionary<string, (string Pattern, string Type, int Risk)>
        {
            { "AWS_KEY", (@"AKIA[0-9A-Z]{16}", "AWS Access Key", 30) },
            { "AWS_SECRET", (@"aws_secret_access_key\s*=\s*['""]?([A-Za-z0-9/+=]{40})['""]?", "AWS Secret Key", 35) },
            { "GCP_KEY", (@"AIza[0-9A-Za-z\\-_]{35}", "GCP API Key", 25) },
            { "GITHUB_TOKEN", (@"ghp_[A-Za-z0-9]{36}", "GitHub Personal Access Token", 30) },
            { "PRIVATE_KEY", (@"-----BEGIN\s+(RSA\s+)?PRIVATE KEY-----", "Private Key", 35) },
            { "API_KEY", (@"api[_-]?key\s*[:=]\s*['""]?([A-Za-z0-9]{20,})['""]?", "API Key", 20) },
            { "PASSWORD", (@"password\s*[:=]\s*['""]?([^'\s""]{8,})['""]?", "Password in config", 25) },
            { "SECRET", (@"secret\s*[:=]\s*['""]?([A-Za-z0-9+/=]{20,})['""]?", "Secret token", 25) },
            { "JWT_TOKEN", (@"eyJ[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*", "JWT Token", 20) },
            { "DATABASE_URL", (@"(mysql|postgresql|mongodb)://[^:]+:[^@]+@", "Database credentials", 30) }
        };

        SearchInFiles(secretPatterns);
    }

    /// <summary>
    /// Поиск паттернов в файлах
    /// </summary>
    private void SearchInFiles(Dictionary<string, (string Pattern, string Type, int Risk)> patterns)
    {
        try
        {
            var layerDirs = FindLayerDirectories();
            foreach (var layerDir in layerDirs)
            {
                string layerId = Path.GetFileName(layerDir) ?? "unknown";
                string layerRoot = Path.Combine(layerDir, "layer");

                if (Directory.Exists(layerRoot))
                {
                    SearchInDirectory(layerRoot, patterns, layerId, layerRoot);
                }
            }
        }
        catch
        {
        }
    }

    /// <summary>
    /// Рекурсивный поиск в директории
    /// </summary>
    private void SearchInDirectory(string directory, Dictionary<string, (string Pattern, string Type, int Risk)> patterns, 
        string layerId, string rootPath, int depth = 0)
    {
        if (depth > 15) return;

        try
        {
            var textExtensions = new[] { ".txt", ".json", ".yml", ".yaml", ".conf", ".config", ".env", ".sh", ".py", ".js", ".ts" };

            foreach (var file in Directory.GetFiles(directory))
            {
                try
                {
                    var fileInfo = new FileInfo(file);
                    if (fileInfo.Length > 10 * 1024 * 1024) continue;

                    string extension = Path.GetExtension(file).ToLower();
                    if (!textExtensions.Contains(extension) && !file.EndsWith("Dockerfile"))
                    {
                        if (!IsTextFile(file)) continue;
                    }

                    string content = File.ReadAllText(file);
                    if (content.Length > 100000) continue;

                    foreach (var pattern in patterns)
                    {
                        var regex = new Regex(pattern.Value.Pattern, RegexOptions.IgnoreCase | RegexOptions.Multiline);
                        var matches = regex.Matches(content);

                        if (matches.Count > 0)
                        {
                            foreach (Match match in matches)
                            {
                                string foundValue = match.Value;
                                if (foundValue.Length > 100) foundValue = foundValue.Substring(0, 100) + "...";

                                _findings.Add(new VulnerabilityFinding
                                {
                                    Type = "SECRET_LEAK",
                                    Severity = pattern.Value.Risk >= 30 ? "HIGH" : "MEDIUM",
                                    Title = $"Найден {pattern.Value.Type}",
                                    Description = $"Потенциальный {pattern.Value.Type} обнаружен в файле",
                                    Evidence = $"Файл: {NormalizePath(file, rootPath)}, Найдено: {foundValue}",
                                    Layer = layerId,
                                    Recommendation = $"Удалите секреты из образа. Используйте секреты из внешних систем (Docker secrets, Vault, etc.)"
                                });
                            }
                        }
                    }
                }
                catch
                {
                }
            }

            foreach (var dir in Directory.GetDirectories(directory))
            {
                string dirName = Path.GetFileName(dir) ?? "";
                if (dirName == "proc" || dirName == "sys" || dirName == "dev" || dirName == ".git")
                    continue;

                SearchInDirectory(dir, patterns, layerId, rootPath, depth + 1);
            }
        }
        catch
        {
        }
    }

    /// <summary>
    /// Проверяет, является ли файл текстовым
    /// </summary>
    private bool IsTextFile(string filePath)
    {
        try
        {
            byte[] buffer = new byte[512];
            using (var stream = File.OpenRead(filePath))
            {
                int bytesRead = stream.Read(buffer, 0, buffer.Length);
                for (int i = 0; i < bytesRead; i++)
                {
                    if (buffer[i] == 0) return false;
                }
            }
            return true;
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// Анализ конфигурационных файлов на небезопасные настройки
    /// </summary>
    private void AnalyzeConfigurationFiles()
    {
        var configPatterns = new[]
        {
            ("DEBUG\\s*=\\s*true", "debug", "DEBUG режим включен в production"),
            ("ALLOWED_HOSTS\\s*=\\s*\\['\\*'\\]", "django", "Django ALLOWED_HOSTS содержит '*'"),
            ("CORS_ORIGIN_ALLOW_ALL\\s*=\\s*True", "django", "CORS разрешает все источники"),
            ("insecure_skip_verify\\s*=\\s*true", "tls", "TLS проверка отключена"),
            ("verify\\s*=\\s*False", "ssl", "SSL верификация отключена"),
            ("password.*=.*['\"]\\s*['\"]", "empty_password", "Пустой пароль в конфигурации")
        };

        var layerDirs = FindLayerDirectories();
        foreach (var layerDir in layerDirs)
        {
            string layerId = Path.GetFileName(layerDir) ?? "unknown";
            AnalyzeConfigInLayer(layerDir, configPatterns, layerId);
        }
    }

    /// <summary>
    /// Анализ конфигурации в слое
    /// </summary>
    private void AnalyzeConfigInLayer(string layerDir, (string Pattern, string Type, string Description)[] patterns, string layerId)
    {
        string layerRoot = Path.Combine(layerDir, "layer");
        if (!Directory.Exists(layerRoot)) return;

        var configFiles = Directory.GetFiles(layerRoot, "*", SearchOption.AllDirectories)
            .Where(f => f.EndsWith(".conf") || f.EndsWith(".config") || f.EndsWith(".ini") || 
                       f.EndsWith(".env") || f.Contains("settings") || f.Contains("config"))
            .Take(100);

        foreach (var file in configFiles)
        {
            try
            {
                if (!IsTextFile(file)) continue;
                string content = File.ReadAllText(file);

                foreach (var pattern in patterns)
                {
                    if (Regex.IsMatch(content, pattern.Pattern, RegexOptions.IgnoreCase))
                    {
                        _findings.Add(new VulnerabilityFinding
                        {
                            Type = "INSECURE_CONFIG",
                            Severity = "MEDIUM",
                            Title = $"Небезопасная конфигурация: {pattern.Type}",
                            Description = pattern.Description,
                            Evidence = $"Файл: {Path.GetFileName(file)}",
                            Layer = layerId,
                            Recommendation = "Исправьте конфигурацию для production окружения"
                        });
                    }
                }
            }
            catch
            {
            }
        }
    }

    /// <summary>
    /// Поиск чувствительных файлов
    /// </summary>
    private void SearchSensitiveFiles()
    {
        var sensitivePatterns = new[]
        {
            ("*.pem", "Certificate file"),
            ("*.key", "Private key file"),
            ("*.p12", "PKCS12 certificate"),
            ("*.pfx", "Certificate file"),
            ("id_rsa", "SSH private key"),
            ("id_dsa", "SSH private key"),
            (".env", "Environment file with secrets"),
            ("secrets.yml", "Secrets file"),
            ("credentials.json", "Credentials file")
        };

        var layerDirs = FindLayerDirectories();
        foreach (var layerDir in layerDirs)
        {
            string layerId = Path.GetFileName(layerDir) ?? "unknown";
            string layerRoot = Path.Combine(layerDir, "layer");

            if (Directory.Exists(layerRoot))
            {
                foreach (var pattern in sensitivePatterns)
                {
                    try
                    {
                        var files = Directory.GetFiles(layerRoot, pattern.Item1, SearchOption.AllDirectories);
                        foreach (var file in files)
                        {
                            _findings.Add(new VulnerabilityFinding
                            {
                                Type = "SENSITIVE_FILE",
                                Severity = "HIGH",
                                Title = $"Чувствительный файл: {pattern.Item2}",
                                Description = $"Найден {pattern.Item2} в образе",
                                Evidence = $"Путь: {NormalizePath(file, layerRoot)}",
                                Layer = layerId,
                                Recommendation = "Удалите чувствительные файлы из образа. Используйте Docker secrets или внешние системы хранения"
                            });
                        }
                    }
                    catch
                    {
                    }
                }
            }
        }
    }

    /// <summary>
    /// Анализ сетевых конфигураций
    /// </summary>
    private void AnalyzeNetworkConfigurations()
    {
        var portPatterns = new[]
        {
            ("listen\\s+(0\\.0\\.0\\.0|\\*|all)", "open_ports", "Слушает на всех интерфейсах (0.0.0.0)"),
            ("bind\\s+(0\\.0\\.0\\.0|\\*|all)", "bind_all", "Привязка ко всем интерфейсам")
        };
    }

    /// <summary>
    /// Анализ старых библиотек (базовый поиск)
    /// </summary>
    private void AnalyzeOldLibraries()
    {
        // Поиск известных уязвимых версий библиотек
        var vulnerableVersions = new Dictionary<string, string[]>
        {
            { "openssl", new[] { "1.0.1", "1.0.2a", "1.0.2b" } },
            { "glibc", new[] { "2.23", "2.24" } }
        };
    }

    /// <summary>
    /// Поиск отладочных инструментов
    /// </summary>
    private void SearchDebugTools()
    {
        var debugTools = new[] { "gdb", "strace", "ltrace", "tcpdump", "wireshark", "valgrind" };

        var layerDirs = FindLayerDirectories();
        foreach (var layerDir in layerDirs)
        {
            string layerId = Path.GetFileName(layerDir) ?? "unknown";
            string layerRoot = Path.Combine(layerDir, "layer");

            if (Directory.Exists(layerRoot))
            {
                foreach (var tool in debugTools)
                {
                    var toolPaths = new[]
                    {
                        Path.Combine(layerRoot, "usr", "bin", tool),
                        Path.Combine(layerRoot, "bin", tool),
                        Path.Combine(layerRoot, "usr", "local", "bin", tool)
                    };

                    foreach (var toolPath in toolPaths)
                    {
                        if (File.Exists(toolPath))
                        {
                            _findings.Add(new VulnerabilityFinding
                            {
                                Type = "DEBUG_TOOL",
                                Severity = "LOW",
                                Title = $"Отладочный инструмент: {tool}",
                                Description = $"Отладочный инструмент {tool} найден в production образе",
                                Evidence = $"Путь: {NormalizePath(toolPath, layerRoot)}",
                                Layer = layerId,
                                Recommendation = "Удалите отладочные инструменты из production образа для уменьшения поверхности атаки"
                            });
                        }
                    }
                }
            }
        }
    }

    /// <summary>
    /// Находит директории слоев
    /// </summary>
    private List<string> FindLayerDirectories()
    {
        var layerDirs = new List<string>();
        
        if (!Directory.Exists(_extractedPath))
            return layerDirs;

        foreach (var dir in Directory.GetDirectories(_extractedPath))
        {
            string dirName = Path.GetFileName(dir) ?? "";
            if (dirName.Length >= 64 && System.Text.RegularExpressions.Regex.IsMatch(dirName, @"^[a-f0-9]{64}$"))
            {
                layerDirs.Add(dir);
            }
            if (File.Exists(Path.Combine(dir, "layer.tar")))
            {
                layerDirs.Add(dir);
            }
        }

        return layerDirs;
    }

    /// <summary>
    /// Нормализует путь
    /// </summary>
    private string NormalizePath(string fullPath, string rootPath)
    {
        if (fullPath.StartsWith(rootPath, StringComparison.OrdinalIgnoreCase))
        {
            string relative = fullPath.Substring(rootPath.Length);
            return relative.Replace('\\', '/').TrimStart('/');
        }
        return fullPath.Replace('\\', '/');
    }
}